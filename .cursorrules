# Next.js + TypeScript Rules

You are an expert Next.js and TypeScript developer. Follow these rules when writing code:

## Tech Stack

- **Framework**: Next.js 14+ (App Router)
- **Language**: TypeScript (strict mode)
- **Styling**: Tailwind CSS
- **UI Components**: shadcn/ui
- **State Management**: Zustand
- **Forms**: React Hook Form + Zod
- **API**: Server Actions (preferred) or API Routes
- **Database**: Prisma ORM
- **Linting**: ESLint configured

## File Naming Conventions

- **Components**: PascalCase (e.g., `UserProfile.tsx`)
- **Utilities/Helpers**: camelCase (e.g., `formatDate.ts`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `API_ENDPOINTS.ts`)
- **Types/Interfaces**: PascalCase (e.g., `UserType.ts` or `types.ts`)

## Project Structure

```
app/
├── (auth)/
│   ├── login/
│   └── register/
├── (dashboard)/
│   ├── layout.tsx
│   ├── page.tsx
│   └── [feature]/
├── api/
│   └── [routes]/
├── components/
│   ├── ui/              # shadcn/ui components
│   ├── features/        # Feature-specific components
│   └── layouts/         # Layout components
├── lib/
│   ├── utils.ts         # Utility functions
│   ├── validations.ts   # Zod schemas
│   └── store/           # Zustand stores
└── types/
    └── index.ts         # TypeScript types
```

## Code Style Rules

1. **Use TypeScript strict mode**
   - Always define types for function parameters and return values
   - Avoid `any` type - use `unknown` if type is truly unknown
   - Use type inference when types are obvious

2. **Server Components by default**
   - Use Server Components unless you need interactivity
   - Add `'use client'` only when necessary (state, effects, event handlers)
   - Keep Server Components at the top of the component tree

3. **Component Structure**
   ```tsx
   'use client' // Only if needed
   
   import { useState } from 'react'
   import { Button } from '@/components/ui/button'
   
   interface ComponentProps {
     title: string
     onClick?: () => void
   }
   
   export function Component({ title, onClick }: ComponentProps) {
     const [state, setState] = useState<string>('')
     
     return (
       <div>
         <h1>{title}</h1>
         <Button onClick={onClick}>Click me</Button>
       </div>
     )
   }
   ```

4. **Use Server Actions for mutations**
   ```tsx
   // app/actions/user.ts
   'use server'
   
   import { z } from 'zod'
   import { revalidatePath } from 'next/cache'
   
   const updateUserSchema = z.object({
     name: z.string().min(1),
     email: z.string().email(),
   })
   
   export async function updateUser(formData: FormData) {
     const rawData = {
       name: formData.get('name'),
       email: formData.get('email'),
     }
     
     const validatedData = updateUserSchema.parse(rawData)
     
     // Database operation
     await prisma.user.update({...})
     
     revalidatePath('/dashboard')
   }
   ```

5. **Form Handling**
   - Always use React Hook Form with Zod validation
   - Use shadcn/ui Form components
   - Show loading states during submission
   ```tsx
   'use client'
   
   import { useForm } from 'react-hook-form'
   import { zodResolver } from '@hookform/resolvers/zod'
   import { z } from 'zod'
   import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form'
   import { Button } from '@/components/ui/button'
   
   const formSchema = z.object({
     email: z.string().email(),
     password: z.string().min(8),
   })
   
   export function LoginForm() {
     const form = useForm<z.infer<typeof formSchema>>({
       resolver: zodResolver(formSchema),
       defaultValues: {
         email: '',
         password: '',
       },
     })
     
     async function onSubmit(values: z.infer<typeof formSchema>) {
       // Handle submission
     }
     
     return (
       <Form {...form}>
         <form onSubmit={form.handleSubmit(onSubmit)}>
           {/* Form fields */}
         </form>
       </Form>
     )
   }
   ```

6. **Error Handling**
   - Use error.tsx for error boundaries
   - Handle errors gracefully with user-friendly messages
   - Log errors server-side
   ```tsx
   // app/error.tsx
   'use client'
   
   export default function Error({
     error,
     reset,
   }: {
     error: Error & { digest?: string }
     reset: () => void
   }) {
     return (
       <div>
         <h2>Something went wrong!</h2>
         <button onClick={() => reset()}>Try again</button>
       </div>
     )
   }
   ```

7. **Loading States**
   - Use loading.tsx for loading UI
   - Show skeleton loaders for better UX
   ```tsx
   // app/loading.tsx
   export default function Loading() {
     return <div>Loading...</div>
   }
   ```

8. **State Management**
   - Use Zustand for client-side global state
   - Prefer Server Components and URL state when possible
   - Keep stores focused and small
   ```tsx
   // lib/store/userStore.ts
   import { create } from 'zustand'
   
   interface UserState {
     user: User | null
     setUser: (user: User) => void
     clearUser: () => void
   }
   
   export const useUserStore = create<UserState>((set) => ({
     user: null,
     setUser: (user) => set({ user }),
     clearUser: () => set({ user: null }),
   }))
   ```

9. **API Routes** (if needed, prefer Server Actions)
   ```tsx
   // app/api/users/route.ts
   import { NextRequest, NextResponse } from 'next/server'
   
   export async function GET(request: NextRequest) {
     try {
       const users = await prisma.user.findMany()
       return NextResponse.json(users)
     } catch (error) {
       return NextResponse.json(
         { error: 'Failed to fetch users' },
         { status: 500 }
       )
     }
   }
   ```

10. **TypeScript Best Practices**
    - Use interfaces for object shapes
    - Use types for unions, intersections, and computed types
    - Export types from a central `types` directory
    ```tsx
    // types/index.ts
    export interface User {
      id: string
      name: string
      email: string
    }
    
    export type UserRole = 'admin' | 'user' | 'guest'
    ```

11. **Styling Guidelines**
    - Use Tailwind utility classes
    - Extract repeated patterns into components
    - Use CSS variables for theming (shadcn/ui pattern)
    - Prefer `className` over inline styles
    ```tsx
    <div className="flex items-center justify-between p-4 bg-background rounded-lg">
      <h2 className="text-lg font-semibold">Title</h2>
    </div>
    ```

12. **Accessibility**
    - Use semantic HTML
    - Add ARIA labels where needed
    - Ensure keyboard navigation works
    - Test with screen readers

13. **Performance**
    - Use `next/image` for images
    - Implement proper caching strategies
    - Use `next/dynamic` for code splitting
    - Optimize bundle size

14. **Security**
    - Validate all user inputs with Zod
    - Sanitize data before displaying
    - Use environment variables for secrets
    - Implement proper authentication/authorization

15. **Testing** (when applicable)
    - Write unit tests for utilities
    - Test Server Actions
    - Use Playwright for E2E tests

## Common Patterns

- **Data Fetching**: Use Server Components with async/await
- **Revalidation**: Use `revalidatePath()` and `revalidateTag()`
- **Redirects**: Use `redirect()` from `next/navigation`
- **Metadata**: Define in `layout.tsx` or `page.tsx`

## Don'ts

- ❌ Don't use `'use client'` unnecessarily
- ❌ Don't fetch data in Client Components (pass as props)
- ❌ Don't use `useEffect` for data fetching
- ❌ Don't ignore TypeScript errors
- ❌ Don't use `any` type
- ❌ Don't create API routes when Server Actions suffice
- ❌ Don't mix Server and Client Component patterns incorrectly

## When I ask you to write code

1. Always use TypeScript
2. Follow the file structure above
3. Use Server Components by default
4. Add proper error handling
5. Include loading states
6. Validate inputs with Zod
7. Use shadcn/ui components when available
8. Follow the naming conventions
9. Add JSDoc comments for complex functions
10. Ensure accessibility

